expalin N+1 problem in hibernate? 

: excution of N+1 number of quries while using hibernate is defined as N+1 problem in hibernate. 
this is arised  : two entities ie.. Employee and  department related to each other having @OnetoMany relationship  between them and you trying to fetch the department details then 
                   we get this isssue. 
                 eg : Department -> id , name, ListOfEmployee.
                                  first query  : select id, name from department; 
                                   according to the result have n number of rows then, n number of quries are excuted here.
                                    addition of this N+1(first query) is the problem .

Solution 1:
 To slove this issue, we can use : select id,name, .... from department d  Join Fetch d.listOfEmployee;
 here internally : select dp.id , dp.name, emp.name, emp.id from  department left join employee on dl.id=emp.id;

solution 2 : 
At reposetory level we can have a annotation as @EnityGraph(attributePaths="addresses").

=======================================================================================================================================================================
do you know  hibernate does not support lazy loading for @Onetoone relationship.?
=======================================================================================================================================================================
why do we use @transient in hibernte?
exception handling in hibernate 
-- roll
hibernate propogation ? 
Answers : 
    REQUIRED (Default): Uses existing transaction or creates new
    REQUIRES_NEW: Always creates new transaction (suspends current if exists)
    SUPPORTS: Runs in transaction if exists, otherwise non-transactional
    NOT_SUPPORTED: Executes non-transactionally (suspends current if exists)
    MANDATORY: Must run within existing transaction
    NEVER: Must not run within transaction
    NESTED: Creates nested transaction if exists.

=======================================================================================================================================================================
hibernate cascading ?
Answers:  
  PERSIST: Saves child when parent is saved.
  MERGE: Updates child when parent is updated.
  REMOVE: Deletes child when parent is deleted.
  REFRESH: Refreshes child when parent is refreshed.
  DETACH: Detaches child when parent is detached.
  ALL: All operations are cascaded.

=======================================================================================================================================================================
why do we use cascading in hibernate ? 

Over a two classes who are related as parent and child , 
if you say @OneToOne(mapping="childClassName", cascade=CascadeType.ALL, )

what are the annotations used in spring boot? -- good.
Answer : application level  --@SpringBootAnnotation -- @ComponantScan, @Configuration, @AutoCongiguratoin.
configuration level ---    @Configuration 
                           @Bean
Controller -- 
@RestController 
@RequestBody 
@PostMapping 
@GetMapping 
@PutMapping 
@RequestParam 
@Pathvariable



real life case of @singleton ? -- good.
-- data base connection, 
-- config mannager 
-- logger 

can we work without using @Transnational annotation ? -- yes we can maintain the session and do the job mannually.
Hibernate level validations ?
@NotNull, 
@Size, ...(min= ? ,max=?)
@Email

@transactional level understanding in hibernate? 
it is all about the either commit or roll back mechanisum of your method or a class 
